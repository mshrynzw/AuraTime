# 開発ガイドライン - バックエンド（Spring Boot）

## 1. 概要

本ドキュメントは、AuraTimeシステムのバックエンド開発（Spring Boot）における開発ガイドラインを定義します。

詳細な開発ガイドラインについては、[開発ガイドライン](./311_開発ガイドライン.md)を参照してください。

### 1.1 技術スタック

- **Spring Boot 3.3.x以上** (Java)
  - Spring Security (認証・認可)
  - Spring Batch (バッチ処理)
  - Spring Data JPA (データベースアクセス)
  - Spring AOP (監査ログ)
- **Java 21 LTS** (またはJava 17 LTS)
- **Gradle** (ビルドツール、Kotlin DSL推奨)
- **PostgreSQL 16.x** (データベース)
- **Redis 7.2.x以上** (キャッシュ・セッションストア)

## 2. アーキテクチャ原則

### 2.1 レイヤー構造

以下の3層アーキテクチャを採用します：

```
Controller (API層)
    ↓
Service (ビジネスロジック層)
    ↓
Repository (データアクセス層)
```

**各レイヤーの責務**:

- **Controller**: HTTPリクエスト/レスポンスの処理、バリデーション、認可チェック
- **Service**: ビジネスロジックの実装、トランザクション管理
- **Repository**: データベースアクセス、クエリ実装

### 2.2 マルチテナント分離（最重要）

**必須原則**:

1. **`company_id`の自動設定**: 全てのAPIエンドポイントで、JWTトークンから`company_id`を取得し、自動設定
2. **リクエストパラメータの無視**: リクエストパラメータやボディから`company_id`を受け取らない
3. **他社データアクセスの防止**: 他社データへのアクセスは403 Forbiddenを返却
4. **フィルタリング**: リポジトリ層で`company_id`を自動フィルタリング

**実装例**:

```java
// ✅ 良い例：JWTからcompany_idを取得
@RestController
@RequestMapping("/api/v1/time-clock/events")
public class TimeClockController {

    @PostMapping
    @PreAuthorize("hasRole('EMPLOYEE')")
    public ResponseEntity<TimeClockEventResponse> createEvent(
            @RequestBody @Valid CreateTimeClockEventRequest request,
            Authentication authentication) {

        // JWTからcompany_idを取得（フィルターで自動設定）
        UUID companyId = getCompanyIdFromAuthentication(authentication);

        // リクエストのcompany_idは無視し、トークンから取得したものを使用
        TimeClockEvent event = timeClockService.createEvent(
            companyId, // トークンから取得
            request
        );

        return ResponseEntity.ok(toResponse(event));
    }
}

// ❌ 悪い例：リクエストからcompany_idを受け取る
@PostMapping
public ResponseEntity<?> createEvent(
        @RequestBody CreateTimeClockEventRequest request) {
    // リクエストのcompany_idを使用（セキュリティリスク）
    UUID companyId = request.getCompanyId(); // ❌
}
```

### 2.3 パッケージ構成

```
com.auratime
├── api
│   └── v1
│       ├── controller      # RESTコントローラー
│       ├── dto             # リクエスト/レスポンスDTO
│       └── exception       # 例外ハンドラー
├── service                 # ビジネスロジック
├── repository              # データアクセス
├── domain                  # エンティティ
├── config                  # 設定クラス
│   ├── security           # セキュリティ設定
│   └── jpa                # JPA設定
└── util                    # ユーティリティ
```

## 3. コーディング規約

### 3.1 Javaコーディング規約

- **スタイルガイド**: Google Java Style Guide準拠
- **IDE設定**: IntelliJ IDEAのGoogle Java Style設定を使用

### 3.2 命名規則

| 種類 | 規則 | 例 |
| :--- | :--- | :--- |
| クラス名 | PascalCase | `TimeClockController`, `TimeClockService` |
| メソッド名 | camelCase | `createEvent`, `findByCompanyId` |
| 定数 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE` |
| パッケージ名 | lowercase | `com.auratime.api.v1` |
| 変数名 | camelCase | `companyId`, `timeClockEvent` |

### 3.3 アノテーションの使用

```java
// ✅ 良い例：適切なアノテーションの使用
@RestController
@RequestMapping("/api/v1/time-clock/events")
@RequiredArgsConstructor
@Slf4j
public class TimeClockController {

    private final TimeClockService timeClockService;

    @PostMapping
    @PreAuthorize("hasRole('EMPLOYEE')")
    public ResponseEntity<TimeClockEventResponse> createEvent(
            @RequestBody @Valid CreateTimeClockEventRequest request,
            Authentication authentication) {
        // 実装
    }
}
```

### 3.4 コードフォーマット

- **インデント**: 4スペース
- **行の長さ**: 120文字以内
- **インポート**: ワイルドカードインポートは使用しない

## 4. セキュリティ

### 4.1 認証・認可

#### JWT認証

```java
// JWTフィルターでcompany_idを取得し、SecurityContextに設定
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) {
        String token = extractToken(request);
        if (token != null && jwtTokenProvider.validateToken(token)) {
            Authentication auth = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        filterChain.doFilter(request, response);
    }
}
```

#### 認可チェック

```java
// ✅ 良い例：@PreAuthorizeで認可を制御
@GetMapping("/api/v1/employees")
@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
public ResponseEntity<List<EmployeeResponse>> getEmployees() {
    // 実装
}

// ✅ 良い例：メソッドレベルで認可
@Service
public class EmployeeService {

    @PreAuthorize("hasRole('ADMIN')")
    public Employee createEmployee(CreateEmployeeRequest request) {
        // 実装
    }
}
```

#### ロール定義

- `system_admin`: システム管理者（全社の設定管理）
- `admin`: 管理者（自社の全データ管理）
- `manager`: マネージャー（部下の勤怠承認）
- `employee`: 従業員（自身のデータのみ）

### 4.2 マルチテナント分離の実装

#### フィルターでの自動設定

```java
@Component
public class CompanyIdFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.isAuthenticated()) {
            UUID companyId = extractCompanyIdFromToken(auth);
            CompanyContext.setCompanyId(companyId);
        }
        chain.doFilter(request, response);
    }
}
```

#### リポジトリでの自動フィルタリング

```java
@Repository
public interface TimeClockEventRepository extends JpaRepository<TimeClockEvent, UUID> {

    // ✅ 良い例：company_idを自動的にフィルタリング
    @Query("SELECT e FROM TimeClockEvent e WHERE e.companyId = :companyId " +
           "AND e.deletedAt IS NULL")
    List<TimeClockEvent> findByCompanyId(@Param("companyId") UUID companyId);

    // ❌ 悪い例：company_idを条件に含めない
    List<TimeClockEvent> findAll(); // ❌ 他社データも取得される
}
```

#### 他社データアクセスの防止

```java
@Service
@Transactional
public class TimeClockService {

    public TimeClockEvent getEvent(UUID eventId) {
        UUID companyId = CompanyContext.getCompanyId();
        TimeClockEvent event = repository.findById(eventId)
            .orElseThrow(() -> new ResourceNotFoundException("Event not found"));

        // 他社データへのアクセスを防止
        if (!event.getCompanyId().equals(companyId)) {
            throw new ForbiddenException("Access denied");
        }

        return event;
    }
}
```

### 4.3 入力検証

```java
// ✅ 良い例：@Validアノテーションでバリデーション
@PostMapping
public ResponseEntity<?> createEvent(
        @RequestBody @Valid CreateTimeClockEventRequest request) {
    // 実装
}

// DTOでのバリデーション
public class CreateTimeClockEventRequest {

    @NotNull(message = "打刻種別は必須です")
    @Pattern(regexp = "in|out|break_in|break_out",
             message = "打刻種別が不正です")
    private String type;

    @NotNull(message = "発生日時は必須です")
    @PastOrPresent(message = "未来時刻は指定できません")
    private LocalDateTime happenedAt;

    @Size(max = 500, message = "備考は500文字以内です")
    private String note;
}
```

### 4.4 SQLインジェクション対策

```java
// ✅ 良い例：プリペアドステートメントを使用（JPAが自動的に使用）
@Query("SELECT e FROM TimeClockEvent e " +
       "WHERE e.companyId = :companyId " +
       "AND e.employeeId = :employeeId " +
       "AND e.happenedAt >= :startDate")
List<TimeClockEvent> findByConditions(
    @Param("companyId") UUID companyId,
    @Param("employeeId") UUID employeeId,
    @Param("startDate") LocalDateTime startDate
);

// ❌ 悪い例：文字列連結でSQLを構築（禁止）
String sql = "SELECT * FROM h_time_clock_events " +
             "WHERE employee_id = '" + employeeId + "'"; // ❌
```

### 4.5 パスワードハッシュ化

```java
// ✅ 良い例：bcryptでパスワードをハッシュ化
@Service
public class UserService {

    private final PasswordEncoder passwordEncoder;

    public User createUser(CreateUserRequest request) {
        String hashedPassword = passwordEncoder.encode(request.getPassword());
        User user = User.builder()
            .email(request.getEmail())
            .passwordHash(hashedPassword)
            .build();
        return userRepository.save(user);
    }
}
```

## 5. データベースアクセス

### 5.1 Spring Data JPAの使用方針

#### エンティティ定義

```java
// ✅ 良い例：エンティティの定義
@Entity
@Table(name = "h_time_clock_events")
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class TimeClockEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "company_id", nullable = false)
    private UUID companyId;

    @Column(name = "employee_id", nullable = false)
    private UUID employeeId;

    @Column(name = "happened_at", nullable = false)
    private LocalDateTime happenedAt;

    @Column(name = "type", nullable = false)
    @Enumerated(EnumType.STRING)
    private TimeClockEventType type;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    // 監査列
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "created_by", nullable = false, updatable = false)
    private UUID createdBy;
}
```

#### リポジトリ実装

```java
// ✅ 良い例：カスタムクエリの実装
@Repository
public interface TimeClockEventRepository extends JpaRepository<TimeClockEvent, UUID> {

    // company_idを必ず条件に含める
    @Query("SELECT e FROM TimeClockEvent e " +
           "WHERE e.companyId = :companyId " +
           "AND e.deletedAt IS NULL " +
           "AND e.employeeId = :employeeId " +
           "AND e.happenedAt >= :startDate " +
           "ORDER BY e.happenedAt DESC")
    List<TimeClockEvent> findByEmployeeAndDateRange(
        @Param("companyId") UUID companyId,
        @Param("employeeId") UUID employeeId,
        @Param("startDate") LocalDateTime startDate
    );

    // ページング対応
    Page<TimeClockEvent> findByCompanyIdAndDeletedAtIsNull(
        UUID companyId,
        Pageable pageable
    );
}
```

### 5.2 トランザクション管理

```java
// ✅ 良い例：@Transactionalでトランザクション管理
@Service
@Transactional
public class TimeClockService {

    @Transactional(readOnly = true) // 読み取り専用
    public List<TimeClockEvent> getEvents(UUID employeeId) {
        UUID companyId = CompanyContext.getCompanyId();
        return repository.findByCompanyIdAndEmployeeId(companyId, employeeId);
    }

    @Transactional // 書き込み（デフォルト）
    public TimeClockEvent createEvent(CreateTimeClockEventRequest request) {
        UUID companyId = CompanyContext.getCompanyId();
        TimeClockEvent event = TimeClockEvent.builder()
            .companyId(companyId)
            .employeeId(request.getEmployeeId())
            .happenedAt(request.getHappenedAt())
            .type(request.getType())
            .createdBy(getCurrentUserId())
            .createdAt(LocalDateTime.now())
            .build();
        return repository.save(event);
    }
}
```

### 5.3 N+1問題の回避

```java
// ❌ 悪い例：N+1問題が発生
@Service
public class EmployeeService {

    public List<EmployeeResponse> getEmployees() {
        List<Employee> employees = employeeRepository.findAll();
        // 各従業員のグループを取得する際にN+1問題が発生
        return employees.stream()
            .map(e -> {
                List<Group> groups = groupRepository.findByEmployeeId(e.getId()); // N回クエリ
                return toResponse(e, groups);
            })
            .toList();
    }
}

// ✅ 良い例：@EntityGraphでEager Loading
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, UUID> {

    @EntityGraph(attributePaths = {"groups"})
    List<Employee> findByCompanyIdAndDeletedAtIsNull(UUID companyId);
}

// ✅ 良い例：JOIN FETCHを使用
@Query("SELECT DISTINCT e FROM Employee e " +
       "LEFT JOIN FETCH e.groups g " +
       "WHERE e.companyId = :companyId " +
       "AND e.deletedAt IS NULL")
List<Employee> findByCompanyIdWithGroups(@Param("companyId") UUID companyId);
```

### 5.4 クエリ最適化

```java
// ✅ 良い例：必要なカラムのみ取得（プロジェクション）
@Query("SELECT new com.auratime.api.v1.dto.TimeClockEventSummaryDTO(" +
       "e.id, e.happenedAt, e.type) " +
       "FROM TimeClockEvent e " +
       "WHERE e.companyId = :companyId " +
       "AND e.deletedAt IS NULL")
List<TimeClockEventSummaryDTO> findSummariesByCompanyId(@Param("companyId") UUID companyId);

// ✅ 良い例：インデックスを活用したクエリ
@Query("SELECT e FROM TimeClockEvent e " +
       "WHERE e.companyId = :companyId " +
       "AND e.employeeId = :employeeId " +
       "AND e.happenedAt BETWEEN :startDate AND :endDate " +
       "AND e.deletedAt IS NULL " +
       "ORDER BY e.happenedAt DESC")
List<TimeClockEvent> findByEmployeeAndDateRange(
    @Param("companyId") UUID companyId,
    @Param("employeeId") UUID employeeId,
    @Param("startDate") LocalDateTime startDate,
    @Param("endDate") LocalDateTime endDate
);
```

### 5.5 ソフト削除の実装

```java
// ✅ 良い例：デフォルトでdeleted_at IS NULLを条件に含める
@Repository
public interface TimeClockEventRepository extends JpaRepository<TimeClockEvent, UUID> {

    // 自動的にdeleted_at IS NULLが条件に含まれる（カスタム実装が必要）
    @Query("SELECT e FROM TimeClockEvent e " +
           "WHERE e.companyId = :companyId " +
           "AND e.deletedAt IS NULL")
    List<TimeClockEvent> findByCompanyId(@Param("companyId") UUID companyId);

    // ソフト削除
    @Modifying
    @Query("UPDATE TimeClockEvent e " +
           "SET e.deletedAt = :deletedAt, e.deletedBy = :deletedBy " +
           "WHERE e.id = :id AND e.companyId = :companyId")
    void softDelete(@Param("id") UUID id,
                   @Param("companyId") UUID companyId,
                   @Param("deletedAt") LocalDateTime deletedAt,
                   @Param("deletedBy") UUID deletedBy);
}
```

## 6. API設計

### 6.1 RESTful APIの原則

| HTTPメソッド | 用途 | 例 |
| :--- | :--- | :--- |
| GET | リソースの取得、一覧表示 | `GET /api/v1/time-clock/events` |
| POST | リソースの作成、アクション実行 | `POST /api/v1/time-clock/events` |
| PATCH | リソースの部分更新 | `PATCH /api/v1/time-records/{id}` |
| PUT | 一括更新、全体置き換え | `PUT /api/v1/shift-assignments/bulk` |
| DELETE | リソースの削除（ソフト削除） | `DELETE /api/v1/employees/{id}` |

### 6.2 エンドポイント命名規則

```
/api/v1/{resource}
/api/v1/{resource}/{id}
/api/v1/{resource}/{id}/{action}
```

**例**:
- `GET /api/v1/time-clock/events` - 打刻イベント一覧
- `POST /api/v1/time-clock/events` - 打刻イベント作成
- `PATCH /api/v1/time-records/{id}` - 勤怠レコード更新
- `POST /api/v1/approval-requests/{id}/approve` - 承認実行

### 6.3 リクエスト/レスポンス形式

#### 成功レスポンス

```java
// 統一されたレスポンス形式
public class ApiResponse<T> {
    private boolean success = true;
    private T data;
    private String requestId;
}

// 使用例
@GetMapping("/api/v1/time-clock/events/{id}")
public ResponseEntity<ApiResponse<TimeClockEventResponse>> getEvent(@PathVariable UUID id) {
    TimeClockEvent event = service.getEvent(id);
    return ResponseEntity.ok(ApiResponse.success(toResponse(event), getRequestId()));
}
```

#### エラーレスポンス

```java
// 統一されたエラーレスポンス形式
public class ErrorResponse {
    private boolean success = false;
    private ErrorDetail error;
    private String requestId;
}

public class ErrorDetail {
    private String code;
    private String message;
    private List<String> details;
}

// 使用例
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException e) {
    ErrorResponse response = ErrorResponse.builder()
        .success(false)
        .error(ErrorDetail.builder()
            .code("RESOURCE_NOT_FOUND")
            .message(e.getMessage())
            .build())
        .requestId(getRequestId())
        .build();
    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
}
```

### 6.4 HTTPステータスコード

| ステータスコード | 用途 | 例 |
| :--- | :--- | :--- |
| 200 OK | 成功 | リソースの取得、更新成功 |
| 201 Created | 作成成功 | リソースの作成成功 |
| 400 Bad Request | リクエストエラー | バリデーションエラー、不正なパラメータ |
| 401 Unauthorized | 認証エラー | トークンが無効、認証が必要 |
| 403 Forbidden | 認可エラー | 権限不足、他社データへのアクセス |
| 404 Not Found | リソース不存在 | 指定されたIDのリソースが存在しない |
| 409 Conflict | 競合エラー | 既に承認済み、締め済み |
| 500 Internal Server Error | サーバーエラー | 予期しないエラー |

### 6.5 バリデーション

```java
// ✅ 良い例：Bean Validationを使用
@PostMapping
public ResponseEntity<?> createEvent(
        @RequestBody @Valid CreateTimeClockEventRequest request) {
    // バリデーションは自動的に実行される
    TimeClockEvent event = service.createEvent(request);
    return ResponseEntity.status(HttpStatus.CREATED).body(toResponse(event));
}

// DTOでのバリデーション
public class CreateTimeClockEventRequest {

    @NotNull(message = "従業員IDは必須です")
    private UUID employeeId;

    @NotNull(message = "打刻種別は必須です")
    @Pattern(regexp = "in|out|break_in|break_out",
             message = "打刻種別が不正です")
    private String type;

    @NotNull(message = "発生日時は必須です")
    @PastOrPresent(message = "未来時刻は指定できません")
    private LocalDateTime happenedAt;

    @Size(max = 500, message = "備考は500文字以内です")
    private String note;
}
```

## 7. バッチ処理（Spring Batch）

### 7.1 バッチジョブの設計方針

```java
// ✅ 良い例：Spring Batchジョブの実装
@Configuration
@RequiredArgsConstructor
public class PayrollCalculationJobConfig {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job payrollCalculationJob() {
        return jobBuilderFactory.get("payrollCalculationJob")
            .start(calculatePayrollStep())
            .next(updatePayslipsStep())
            .build();
    }

    @Bean
    public Step calculatePayrollStep() {
        return stepBuilderFactory.get("calculatePayrollStep")
            .<Employee, Payslip>chunk(100)
            .reader(employeeReader())
            .processor(payrollProcessor())
            .writer(payslipWriter())
            .build();
    }
}
```

### 7.2 チャンク処理の実装

```java
// ✅ 良い例：大量データをチャンク処理
@Component
public class PayrollCalculationProcessor implements ItemProcessor<Employee, Payslip> {

    @Override
    public Payslip process(Employee employee) throws Exception {
        // 給与計算処理
        return calculatePayslip(employee);
    }
}

@Component
public class PayslipWriter implements ItemWriter<Payslip> {

    @Override
    public void write(List<? extends Payslip> payslips) throws Exception {
        // チャンク単位で一括保存
        payslipRepository.saveAll(payslips);
    }
}
```

### 7.3 ジョブ実行状況の管理

```java
// ✅ 良い例：ジョブ実行状況を記録
@Service
public class JobRunService {

    public UUID startJob(JobType jobType, Map<String, Object> params) {
        JobRun jobRun = JobRun.builder()
            .companyId(CompanyContext.getCompanyId())
            .jobType(jobType)
            .status(JobRunStatus.RUNNING)
            .startedAt(LocalDateTime.now())
            .params(params)
            .requestId(getRequestId())
            .createdBy(getCurrentUserId())
            .build();
        return jobRunRepository.save(jobRun).getId();
    }

    public void completeJob(UUID jobRunId, Map<String, Object> result) {
        JobRun jobRun = jobRunRepository.findById(jobRunId)
            .orElseThrow(() -> new ResourceNotFoundException("Job run not found"));
        jobRun.complete(result);
        jobRunRepository.save(jobRun);
    }
}
```

### 7.4 エラーハンドリングとリトライ

```java
// ✅ 良い例：リトライとスキップの設定
@Bean
public Step calculatePayrollStep() {
    return stepBuilderFactory.get("calculatePayrollStep")
        .<Employee, Payslip>chunk(100)
        .reader(employeeReader())
        .processor(payrollProcessor())
        .writer(payslipWriter())
        .faultTolerant()
        .retryLimit(3)
        .retry(DataAccessException.class)
        .skipLimit(10)
        .skip(CalculationException.class)
        .build();
}
```

## 8. 監査ログ

### 8.1 Spring AOPによる自動記録

```java
// ✅ 良い例：AOPで監査ログを自動記録
@Aspect
@Component
@RequiredArgsConstructor
public class AuditLogAspect {

    private final AuditLogService auditLogService;

    @Around("@annotation(com.auratime.annotation.Auditable)")
    public Object logAudit(ProceedingJoinPoint joinPoint) throws Throwable {
        String action = getAction(joinPoint);
        Object[] args = joinPoint.getArgs();

        // 変更前のデータを取得
        Object beforeData = getBeforeData(joinPoint, args);

        // メソッド実行
        Object result = joinPoint.proceed();

        // 変更後のデータを取得
        Object afterData = getAfterData(result);

        // 監査ログを記録
        auditLogService.record(action, beforeData, afterData);

        return result;
    }
}
```

### 8.2 created_by、updated_byの自動設定

```java
// ✅ 良い例：JPAリスナーで自動設定
@EntityListeners(AuditingEntityListener.class)
@Entity
public class TimeClockEvent {

    @CreatedBy
    @Column(name = "created_by", nullable = false, updatable = false)
    private UUID createdBy;

    @LastModifiedBy
    @Column(name = "updated_by", nullable = false)
    private UUID updatedBy;
}

// 監査情報を提供する実装
@Component
public class AuditorAwareImpl implements AuditorAware<UUID> {

    @Override
    public Optional<UUID> getCurrentAuditor() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.isAuthenticated()) {
            return Optional.of(extractUserId(auth));
        }
        return Optional.empty();
    }
}
```

## 9. 例外処理

### 9.1 統一された例外ハンドラー

```java
// ✅ 良い例：@ControllerAdviceで統一された例外処理
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(
            ResourceNotFoundException e, HttpServletRequest request) {
        log.warn("Resource not found: {}", e.getMessage());
        ErrorResponse response = ErrorResponse.builder()
            .success(false)
            .error(ErrorDetail.builder()
                .code("RESOURCE_NOT_FOUND")
                .message(e.getMessage())
                .build())
            .requestId(getRequestId(request))
            .build();
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(
            ForbiddenException e, HttpServletRequest request) {
        log.warn("Access forbidden: {}", e.getMessage());
        ErrorResponse response = ErrorResponse.builder()
            .success(false)
            .error(ErrorDetail.builder()
                .code("FORBIDDEN")
                .message(e.getMessage())
                .build())
            .requestId(getRequestId(request))
            .build();
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            MethodArgumentNotValidException e, HttpServletRequest request) {
        List<String> details = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .toList();

        ErrorResponse response = ErrorResponse.builder()
            .success(false)
            .error(ErrorDetail.builder()
                .code("VALIDATION_ERROR")
                .message("入力値が不正です")
                .details(details)
                .build())
            .requestId(getRequestId(request))
            .build();
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
}
```

### 9.2 カスタム例外の定義

```java
// ✅ 良い例：カスタム例外の定義
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

public class ForbiddenException extends RuntimeException {
    public ForbiddenException(String message) {
        super(message);
    }
}

public class ConflictException extends RuntimeException {
    public ConflictException(String message) {
        super(message);
    }
}
```

## 10. ログ

### 10.1 SLF4J + Logbackの使用

```java
// ✅ 良い例：ログの出力
@Slf4j
@Service
public class TimeClockService {

    public TimeClockEvent createEvent(CreateTimeClockEventRequest request) {
        log.info("Creating time clock event: employeeId={}, type={}",
                 request.getEmployeeId(), request.getType());

        try {
            TimeClockEvent event = // 作成処理
            log.info("Time clock event created: id={}", event.getId());
            return event;
        } catch (Exception e) {
            log.error("Failed to create time clock event: employeeId={}, type={}",
                     request.getEmployeeId(), request.getType(), e);
            throw e;
        }
    }
}
```

### 10.2 ログレベル

| レベル | 用途 | 例 |
| :--- | :--- | :--- |
| DEBUG | デバッグ情報 | 詳細な処理フロー、変数の値 |
| INFO | 通常の処理情報 | リクエスト受信、処理完了 |
| WARN | 警告 | 非推奨機能の使用、リトライ |
| ERROR | エラー | 例外発生、処理失敗 |

### 10.3 ログ出力方針

- **リクエストID**: 全てのログに`request_id`を含める
- **company_id**: セキュリティ上問題ない範囲で`company_id`を含める
- **機密情報**: パスワード、トークン、個人情報はログに出力しない

```java
// ✅ 良い例：リクエストIDを含める
log.info("Processing request: requestId={}, companyId={}, employeeId={}",
         requestId, companyId, employeeId);

// ❌ 悪い例：機密情報をログに出力
log.info("User login: email={}, password={}", email, password); // ❌
```

## 11. テスト

### 11.1 単体テスト（JUnit 5 + Mockito）

```java
// ✅ 良い例：単体テストの実装
@ExtendWith(MockitoExtension.class)
class TimeClockServiceTest {

    @Mock
    private TimeClockEventRepository repository;

    @InjectMocks
    private TimeClockService service;

    @Test
    void testCreateEvent() {
        // Given
        CreateTimeClockEventRequest request = CreateTimeClockEventRequest.builder()
            .employeeId(UUID.randomUUID())
            .type("in")
            .happenedAt(LocalDateTime.now())
            .build();

        TimeClockEvent savedEvent = TimeClockEvent.builder()
            .id(UUID.randomUUID())
            .build();

        when(repository.save(any(TimeClockEvent.class))).thenReturn(savedEvent);

        // When
        TimeClockEvent result = service.createEvent(request);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getId()).isEqualTo(savedEvent.getId());
        verify(repository).save(any(TimeClockEvent.class));
    }
}
```

### 11.2 統合テスト（Testcontainers）

```java
// ✅ 良い例：Testcontainersを使用した統合テスト
@SpringBootTest
@Testcontainers
class TimeClockControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void testCreateEvent() {
        // テスト実装
    }
}
```

### 11.3 マルチテナント分離のテスト（重点）

```java
// ✅ 良い例：マルチテナント分離のテスト
@Test
void testMultiTenantIsolation() {
    // Given: 会社Aと会社Bのデータを作成
    UUID companyA = UUID.randomUUID();
    UUID companyB = UUID.randomUUID();

    TimeClockEvent eventA = createEvent(companyA, employeeA);
    TimeClockEvent eventB = createEvent(companyB, employeeB);

    // When: 会社Aのユーザーでログインして取得
    setCurrentCompany(companyA);
    List<TimeClockEvent> events = service.getEvents(employeeA.getId());

    // Then: 会社Aのデータのみ取得できる
    assertThat(events).hasSize(1);
    assertThat(events.get(0).getId()).isEqualTo(eventA.getId());
    assertThat(events).noneMatch(e -> e.getCompanyId().equals(companyB));
}

@Test
void testAccessOtherCompanyData() {
    // Given: 会社BのデータID
    UUID companyB = UUID.randomUUID();
    UUID eventIdB = createEvent(companyB, employeeB).getId();

    // When: 会社Aのユーザーでアクセス
    setCurrentCompany(companyA);

    // Then: 403 Forbiddenが返される
    assertThatThrownBy(() -> service.getEvent(eventIdB))
        .isInstanceOf(ForbiddenException.class)
        .hasMessageContaining("Access denied");
}
```

### 11.4 テストデータの準備

```java
// ✅ 良い例：テストデータの準備
@Sql(scripts = "/test-data/employees.sql", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(scripts = "/test-data/cleanup.sql", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
class EmployeeServiceTest {
    // テスト実装
}
```

## 12. パフォーマンス

### 12.1 キャッシュ戦略

```java
// ✅ 良い例：Spring Cacheを使用
@Service
@CacheConfig(cacheNames = "leaveTypes")
public class LeaveTypeService {

    @Cacheable(key = "#companyId")
    public List<LeaveType> getLeaveTypes(UUID companyId) {
        return leaveTypeRepository.findByCompanyIdAndDeletedAtIsNull(companyId);
    }

    @CacheEvict(key = "#companyId")
    public LeaveType createLeaveType(UUID companyId, CreateLeaveTypeRequest request) {
        // 作成処理
    }
}
```

### 12.2 クエリ最適化

```java
// ✅ 良い例：インデックスを活用したクエリ
@Query("SELECT e FROM TimeClockEvent e " +
       "WHERE e.companyId = :companyId " +
       "AND e.employeeId = :employeeId " +
       "AND e.happenedAt >= :startDate " +
       "AND e.happenedAt < :endDate " +
       "AND e.deletedAt IS NULL " +
       "ORDER BY e.happenedAt DESC")
List<TimeClockEvent> findByEmployeeAndDateRange(
    @Param("companyId") UUID companyId,
    @Param("employeeId") UUID employeeId,
    @Param("startDate") LocalDateTime startDate,
    @Param("endDate") LocalDateTime endDate
);
// インデックス: (company_id, employee_id, happened_at)
```

### 12.3 大量データ処理

```java
// ✅ 良い例：ページングを使用
@GetMapping("/api/v1/time-clock/events")
public ResponseEntity<Page<TimeClockEventResponse>> getEvents(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    UUID companyId = CompanyContext.getCompanyId();
    Pageable pageable = PageRequest.of(page, size, Sort.by("happenedAt").descending());
    Page<TimeClockEvent> events = repository.findByCompanyIdAndDeletedAtIsNull(
        companyId, pageable);
    return ResponseEntity.ok(events.map(this::toResponse));
}
```

## 13. ID管理

### 13.1 UUID v7の使用

```java
// ✅ 良い例：UUID v7を使用
@Entity
public class TimeClockEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid DEFAULT gen_uuid_v7()")
    private UUID id;
}
```

### 13.2 ID生成タイミング

- **データベース側で生成**: `DEFAULT gen_uuid_v7()`を使用
- **アプリケーション側で生成**: 必要な場合は`UUID.randomUUID()`を使用（UUID v4）

## 14. よくある問題と対処法

| 問題 | 原因 | 対処法 |
| :--- | :--- | :--- |
| マルチテナント分離の不備 | `company_id`を条件に含めていない | 全てのクエリに`company_id`を含める |
| N+1問題 | 関連エンティティを個別に取得 | `@EntityGraph`や`JOIN FETCH`を使用 |
| トランザクション境界の誤り | `@Transactional`の配置が不適切 | Service層に`@Transactional`を配置 |
| パフォーマンス問題 | インデックスが不足 | `company_id`を含む複合インデックスを作成 |
| メモリリーク | 大量データを一度に取得 | ページングやチャンク処理を使用 |

## 15. チェックリスト

### 15.1 コードレビュー時の確認項目

- [ ] 全てのAPIエンドポイントで認証・認可が実装されているか
- [ ] `company_id`がJWTトークンから取得され、自動設定されているか
- [ ] リクエストパラメータから`company_id`を受け取っていないか
- [ ] 他社データへのアクセスを防止するチェックが実装されているか
- [ ] 全てのクエリに`company_id`が条件として含まれているか
- [ ] N+1問題が発生していないか
- [ ] トランザクション境界が適切か
- [ ] エラーハンドリングが統一されているか
- [ ] ログに機密情報が含まれていないか
- [ ] テストが実装されているか（特にマルチテナント分離のテスト）

### 15.2 実装時の確認項目

- [ ] `@PreAuthorize`で適切な認可チェックが実装されているか
- [ ] `@Valid`でバリデーションが実装されているか
- [ ] `@Transactional`が適切に配置されているか
- [ ] 監査列（`created_by`, `updated_by`）が自動設定されているか
- [ ] ソフト削除が実装されているか
- [ ] ページングが実装されているか（大量データの場合）
- [ ] ログに`request_id`が含まれているか

## 16. 参考ドキュメント

- [開発ガイドライン](./311_開発ガイドライン.md): 全般的な開発ガイドライン
- [開発順序](./300_概要.md): 開発フェーズの概要
- [Git運用](./310_Git運用.md): ブランチ戦略、コミットメッセージ規約
- [API基本方針](../200_詳細設計/240_API.md): REST方針、認証、エラーハンドリング
- [DB設計方針](../200_詳細設計/221_DB設計.md): マルチテナント、ソフト削除、監査列
- [セキュリティ設計](../200_詳細設計/260_セキュリティー.md): 認証認可、個人情報保護
- [テスト設計](../400_テスト/400_テスト設計.md): テスト方針、重点テスト項目
