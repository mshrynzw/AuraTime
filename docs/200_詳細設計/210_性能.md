# 性能設計

## 1. 目標スループット

### スループットとは
スループットは、システムが単位時間あたりに処理できるリクエスト数やトランザクション数を表します。目標スループットを設定することで、システムの性能要件を明確にし、適切な最適化を行います。

### 目標値
- **打刻処理**: ピーク時（出社/退社前後）に数千リクエスト/秒を遅延なく処理すること。
- **給与計算**: 1万人規模の計算を数分以内で完了させること。

### 目標達成のための具体的な方法

#### 1. 負荷テストの実施
- **ツール**: JMeter、Gatling、k6等を使用
- **実施タイミング**: 
  - 各フェーズの実装完了時
  - 本番環境デプロイ前
  - 定期的な性能検証
- **テストシナリオ**:
  - 打刻API: 同時1000リクエスト/秒を想定
  - 給与計算: 1万人分のデータで実行時間を測定

#### 2. ボトルネックの特定
- **監視ツール**: 
  - CloudWatch Metrics（CPU、メモリ、DB接続数）
  - RDS Performance Insights（クエリパフォーマンス）
  - APM（Application Performance Monitoring）ツール
- **確認ポイント**:
  - データベースのクエリ実行時間
  - アプリケーションサーバーのCPU/メモリ使用率
  - ネットワークレイテンシ
  - Redisのキャッシュヒット率

#### 3. 最適化の実施
- **データベース最適化**:
  - インデックスの追加・見直し（セクション2参照）
  - クエリの最適化（N+1問題の解消）
  - 接続プールの調整
- **アプリケーション最適化**:
  - キャッシュの活用（セクション4参照）
  - 非同期処理の導入（給与計算など）
  - バッチ処理の最適化
- **インフラ最適化**:
  - オートスケーリングの設定
  - Read Replicaの活用
  - CDNの活用（静的ファイル）

#### 4. 継続的な監視
- **本番環境での監視**:
  - CloudWatch Alarmsで閾値を設定
  - レスポンスタイムの監視
  - エラー率の監視
- **定期的な見直し**:
  - 月次でパフォーマンスメトリクスをレビュー
  - ボトルネックの特定と改善
  - スケーリングポリシーの見直し

### 実装例（負荷テスト）

#### JMeterでの負荷テスト例
```xml
<!-- 打刻APIの負荷テスト設定例 -->
<ThreadGroup>
  <stringProp name="ThreadGroup.num_threads">1000</stringProp>
  <stringProp name="ThreadGroup.ramp_time">60</stringProp>
  <stringProp name="ThreadGroup.duration">300</stringProp>
</ThreadGroup>
```

#### パフォーマンステストの実施手順
1. **テスト環境の準備**
   - 本番環境と同等の構成を用意
   - テストデータの投入（1万人分の従業員データ等）
2. **ベースラインの測定**
   - 現在の性能を測定
   - 目標値との差を確認
3. **負荷テストの実行**
   - 段階的に負荷を増加
   - ボトルネックを特定
4. **最適化の実施**
   - ボトルネックを解消
   - 再テストで改善を確認
5. **目標値の達成確認**
   - 目標スループットを達成しているか確認
   - 継続的な監視体制を構築

## 2. クエリ最適化

### インデックス最適化
- **基本方針**: `company_id` を含む複合インデックスを活用し、フルテーブルスキャンを防止する。
- **実装方法**:
  ```sql
  -- 例: time_clock_eventsテーブルのインデックス
  CREATE INDEX ix_time_clock_events_company_date 
    ON time_clock_events(company_id, happened_at);
  
  -- 例: employeesテーブルのインデックス
  CREATE INDEX ix_employees_company_group 
    ON employees(company_id, group_id);
  ```
- **インデックス設計のポイント**:
  - `company_id`を最初のカラムに配置（マルチテナント分離のため）
  - よく使われる検索条件の組み合わせで複合インデックスを作成
  - インデックスの過剰作成は避ける（INSERT/UPDATEが遅くなる）
- **確認方法**:
  - `EXPLAIN ANALYZE`でクエリプランを確認
  - RDS Performance Insightsでスロークエリを特定
  - インデックス使用率を監視

### N+1問題の解決
- **問題**: ORMが関連データを取得する際、1回のクエリで取得すべきデータをN+1回クエリしてしまう
- **解決方法**: Eager Loadingを徹底し、クエリ回数を削減する
- **実装例（Spring Data JPA）**:
  ```java
  // ❌ 悪い例（N+1問題が発生）
  @Query("SELECT e FROM Employee e WHERE e.companyId = :companyId")
  List<Employee> findByCompanyId(@Param("companyId") UUID companyId);
  // 各EmployeeのGroupを取得するために追加クエリが発生
  
  // ✅ 良い例（JOIN FETCHでEager Loading）
  @Query("SELECT e FROM Employee e " +
         "JOIN FETCH e.group " +
         "WHERE e.companyId = :companyId")
  List<Employee> findByCompanyIdWithGroup(@Param("companyId") UUID companyId);
  
  // ✅ 良い例（@EntityGraphを使用）
  @EntityGraph(attributePaths = {"group", "shiftAssignments"})
  List<Employee> findByCompanyId(UUID companyId);
  ```
- **確認方法**:
  - Hibernateの`show-sql`を有効化してクエリ数を確認
  - ログでクエリ実行回数を監視
  - APMツールでN+1問題を検出

### 大量処理の最適化
- **問題**: 給与計算など、大量のデータを一度に処理する際にメモリ不足やタイムアウトが発生
- **解決方法**: `FETCH`や`CURSOR`を使い、メモリ消費を抑えたバッチ処理を行う
- **実装例（Spring Batch）**:
  ```java
  // ✅ バッチ処理の例
  @Bean
  public Step calculatePayrollStep() {
    return stepBuilderFactory.get("calculatePayrollStep")
      .<Employee, Payslip>chunk(100) // 100件ずつ処理
      .reader(employeeReader())
      .processor(payrollProcessor())
      .writer(payslipWriter())
      .build();
  }
  
  // ✅ ストリーミング処理の例（大量データの読み込み）
  @Query(value = "SELECT * FROM employees WHERE company_id = :companyId", 
         nativeQuery = true)
  Stream<Employee> streamByCompanyId(@Param("companyId") UUID companyId);
  ```
- **最適化のポイント**:
  - チャンクサイズの調整（100〜1000件が目安）
  - トランザクション境界の最適化
  - 並列処理の活用（可能な場合）
  - メモリ使用量の監視

### クエリ最適化の手順
1. **スロークエリの特定**
   - RDS Performance Insightsで実行時間の長いクエリを特定
   - ログから実行時間が100ms以上のクエリを抽出
2. **クエリプランの確認**
   - `EXPLAIN ANALYZE`で実行プランを確認
   - フルテーブルスキャンやインデックス未使用を特定
3. **最適化の実施**
   - インデックスの追加・見直し
   - JOINの最適化
   - サブクエリの見直し
4. **効果の確認**
   - 最適化後の実行時間を測定
   - 継続的に監視

## 3. スケーラビリティ

### スケーラビリティとは
スケーラビリティは、システムの負荷が増加した際に、リソースを追加することで性能を維持・向上させる能力です。垂直スケーリング（サーバーの性能向上）と水平スケーリング（サーバー台数の増加）があります。

### Read Replica（読み取り専用レプリカ）
- **目的**: 参照系の重いレポート出力などはリードレプリカに分散し、メインDBの負荷を軽減
- **適用範囲**:
  - レポート生成（給与明細一覧、勤怠集計レポート等）
  - ダッシュボード表示
  - 統計情報の取得
- **実装方法（Spring Boot）**:
  ```java
  // 読み取り専用レプリカを使用する設定
  @Configuration
  public class DataSourceConfig {
    @Bean
    @Primary
    public DataSource primaryDataSource() {
      // メインDB（書き込み用）
      return DataSourceBuilder.create()
        .url("jdbc:postgresql://main-db:5432/auratime")
        .build();
    }
    
    @Bean
    public DataSource readReplicaDataSource() {
      // 読み取り専用レプリカ
      return DataSourceBuilder.create()
        .url("jdbc:postgresql://read-replica:5432/auratime")
        .build();
    }
  }
  
  // 読み取り専用レプリカを使用するRepository
  @Repository
  @Transactional(readOnly = true)
  public interface ReportRepository extends JpaRepository<TimeRecord, UUID> {
    // 自動的に読み取り専用レプリカを使用
  }
  ```
- **AWS RDSでの設定**:
  - RDS Read Replicaを作成
  - アプリケーションから読み取り専用接続を設定
  - レプリケーションラグを監視
- **注意点**:
  - レプリケーションラグ（数秒〜数分の遅延）を考慮
  - 最新データが必要な処理ではメインDBを使用
  - 書き込み処理は必ずメインDBを使用

### 水平分散（オートスケーリング）
- **目的**: アプリケーションサーバーはステートレスに保ち、負荷に応じてオートスケーリングさせる
- **ステートレス設計の原則**:
  - セッション情報をRedis等の外部ストレージに保存
  - サーバー間で状態を共有しない
  - ファイルアップロードはS3等の外部ストレージを使用
- **実装方法（AWS ECS）**:
  ```yaml
  # ECS Auto Scaling設定例
  AutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: 2
      MaxCapacity: 10
      ResourceId: service/auratime-cluster/auratime-service
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      TargetTrackingScalingPolicies:
        - PolicyName: cpu-scaling
          TargetValue: 70.0
          PredefinedMetricSpecification:
            PredefinedMetricType: ECSServiceAverageCPUUtilization
        - PolicyName: memory-scaling
          TargetValue: 80.0
          PredefinedMetricSpecification:
            PredefinedMetricType: ECSServiceAverageMemoryUtilization
  ```
- **スケーリングポリシー**:
  - **CPU使用率**: 70%を超えたらスケールアウト
  - **メモリ使用率**: 80%を超えたらスケールアウト
  - **リクエスト数**: ALBのリクエスト数に基づくスケーリング
- **監視と調整**:
  - CloudWatch Metricsでスケーリングイベントを監視
  - スケールアウト/インの頻度を確認
  - 必要に応じて閾値を調整

### キャッシュによるスケーラビリティ向上
- **目的**: データベースへの負荷を分散し、スケーラビリティを向上
- **実装**: セクション4「キャッシュ戦略」を参照
- **効果**:
  - データベースへのクエリ数を削減
  - レスポンスタイムの改善
  - サーバーリソースの効率的な利用

### スケーラビリティ設計のチェックリスト
- [ ] アプリケーションサーバーがステートレスである
- [ ] セッション情報を外部ストレージ（Redis）に保存している
- [ ] ファイルアップロードは外部ストレージ（S3）を使用している
- [ ] オートスケーリングが設定されている
- [ ] Read Replicaが設定されている（必要に応じて）
- [ ] キャッシュが適切に活用されている
- [ ] 負荷テストでスケーラビリティを検証している

## 4. キャッシュ戦略

### キャッシュとは
キャッシュは、頻繁に参照されるデータを高速なメモリ（Redis）に一時保存することで、データベースへのアクセスを減らし、処理速度を向上させる仕組みです。

### キャッシュの場所
- **バックエンド（Spring Boot）とRedisの間**: アプリケーション層でのキャッシュ
- **目的**: データベースアクセスを減らして処理を高速化
- **技術**: Redis（分散キャッシュ）を使用

### キャッシュの流れ
```
1. ユーザーがリクエスト
   ↓
2. Spring BootがRedisを確認
   ↓
3a. キャッシュにデータがある → Redisから返す（高速）
3b. キャッシュにデータがない → データベースから取得 → Redisに保存 → 返す
   ↓
4. 次回以降はキャッシュから返す（高速）
```

### キャッシュを使うデータ（推奨）
- **マスタデータ**: 頻繁に参照されるが、変更が少ないデータ
  - 休暇タイプ（`leave_types`）
  - 給与項目名（`pay_items`）
  - グループ情報（`groups`）
  - シフトテンプレート（`shift_templates`）
- **特徴**: 
  - 読み取りが多い
  - 更新頻度が低い
  - 整合性の要求が比較的低い

### キャッシュを使わないデータ（注意）
- **整合性が重要なデータ**: 常に最新である必要があるデータ
  - 労働時間（`time_records`）
  - 給与金額（`payslips`）
  - 打刻イベント（`time_clock_events`）
  - 承認ステータス（`approval_requests`）
- **理由**: 
  - キャッシュを使うと、古いデータが返される可能性がある
  - 金額や労働時間の誤りは重大な問題につながる

### 実装方法（Spring Boot）
```java
// キャッシュを使う例
@GetMapping("/leave-types")
@Cacheable("leaveTypes") // キャッシュを有効化
public List<LeaveType> getLeaveTypes() {
    return leaveTypeRepository.findAll();
}

// キャッシュを更新する例（データ更新時）
@PutMapping("/leave-types/{id}")
@CacheEvict(value = "leaveTypes", allEntries = true) // キャッシュをクリア
public LeaveType updateLeaveType(@PathVariable UUID id, @RequestBody LeaveType data) {
    return leaveTypeRepository.save(data);
}
```

### Redisの設定
- **用途**: 分散キャッシュ、セッション管理
- **本番環境**: AWS ElastiCache (Redis 7.2.x)
- **開発環境**: Docker Composeで起動
- **設定**: Spring Bootの`application.yml`で設定
